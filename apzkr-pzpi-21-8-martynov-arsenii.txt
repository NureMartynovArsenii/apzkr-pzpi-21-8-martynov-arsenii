Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни “Архітектура програмного забезпечення ”
Тема роботи: Програмна система для управління кліматом в дитячих садках


	Студент гр. ПЗПІ-21-8		________________ Мартинов А.В.
   (підпис)

	Керівник роботи			________________ ст.викл. Сокорчук І.П.
						(підпис)
						   Роботу захищено «__»_________2024 р.
						    з оцінкою__________________________


	Комісія: 			          _________________ доц. Лещинський В.О.
							(підпис)
_________________ доц. Лещинська І.О.
							(підпис)
_________________ ст.викл. Сокорчук І.П.
							(підпис)
Харків
2024 р.
Харківський національний університет радіоелектроніки     


Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	6	       
Навчальна дисципліна  Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                     Мартинову Арсенію Владиславовичу				
1. Тема роботи: 	«Програмна система для управління кліматом в дитячих садках»												
2. Термін узгодження завдання курсової роботи «1»   	квітня      2024 р.
3. Термін здачі студентом закінченої роботи «15»   	червня     2024 р.
4. Вихідні дані до проекту (роботи): В програмній системі передбачити:
моніторинг клімату, управління системами температури та вологості, моніторинг освітленості. Використовувати ОС Windows 10 або 11, СУБД MongoDB,середовище розробки Microsoft Visual Studio 2022
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, архітектура програмної системи
структура бази даних, опис програмної системи, висновки, перелік посилань,  додатки									 
6. Перелік графічного матеріалу з точним зазначенням обов’язкових креслень
модель даних бази даних, діаграма діяльності, діаграма компонентів, діаграма прецедентів, діаграма розгортання						


КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація
програмного проекту	02.04.2024	Виконано
2	Проектування програмного
проекту	12.04.2024	Виконано
3	Кодування програмного проекту	26.04.2024	Виконано
4	Оформлення пояснювальної
записки	01.06.2024	Виконано
5	Захист курсової роботи	15.06.2024	

Дата видачі завдання «1»  квітня   2024 р.

Керівник 				______________ ст.викл. Сокорчук І.П.
(підпис)

Завдання прийняв до виконання
ст.гр. ПЗПІ-21-8				_____________ Мартинов А.В.
(підпис)

РЕФЕРАТ


Пояснювальна записка до курсової роботи: 80 с., 25 рис., 2 табл., 4 додатки, 8 джерел.
	БЕЗПЕКА, ВЕНТИЛЯЦІЯ, ВОЛОГІСТЬ, ДИТЯЧИЙ САДОК, ЕНЕРГОЕФЕКТИВНІСТЬ, КЛІМАТ, МОНІТОРИНГ, ОПАЛЕННЯ, ОСВІТЛЕННЯ, ПОВІТРЯ, ТЕМПЕРАТУРА, ТЕРМОСТАТ.
	Об’єктом дослідження є дитячі садки, а саме найактуальніше питання на сьогоднішній день стосується управління кліматом в дитячих садках, для того щоб діти могли перебувати в комфорті, а батьки могли бути впевненими у гарних кліматичних умовах своїх дітей.
	Мета курсового проекту є розробка системи, яка надасть змогу керувати кліматом в дитячих садках, а саме моніторинг клімату, насиченість киснем, налаштування системи вентиляції, опалення, освітлення, планування режиму клімату, сповіщення про відхилення від норми. 
	Методи розробки базуються на мові програмування C# за допомогою фреймворку ASP.NET Core 6.0 для серверної частини, в якості бази даних обрана MongoDB, для клієнтської частини використовується бібліотека React, в якості IoT-пристрою був обран ESP32 на мові програмування С++.
	За результатами роботи було розроблено програмну систему для управління кліматом в дитячих садках. Ця система складається з серверної частини, IoT-пристрою та клієнтської частини.

ЗМІСТ


Вступ……………………………………………………………………………...7
1 Аналіз предметної області…………………………………………………….8
   1.1 Бізнес-вимоги………………………………………………………………8
      1.1.1 Бізнес-можливості……………………………………………………..8
      1.1.2 Бізнес-цілі та критерії успіху…………………………………………10
      1.1.3 Потреби клієнта або ринку……………………………………………11
      1.1.4 Бізнес-ризики…………………………………………………………..12
   1.2 Бачення рішення…………………………………………………………...14
      1.2.1 Окреслення концепції…………………………………………………14
      1.2.2 Головна функціональність…………………………………………….15
      1.2.3 Припущення і залежності……………………………………………..16
   1.3 Сфера застосування та обмеження……………………………………….17
      1.3.1 Рамки первинного випуску……………………………………………17
      1.3.2 Рамки наступних випусків……………………………………………19
      1.3.3 Обмеження та винятки………………………………………………...20
   1.4 Бізнес-контекст…………………………………………………………….21
      1.4.1 Профілі зацікавлених сторін………………………………………….21     
      1.4.2 Пріоритети проекту……………………………………………………22
      1.4.3 Операційне середовище……………………………………………….23
2 Архітектура програмної системи …………………………………………….24
   2.1 Архітектура серверної частини…………………………………………...24
   2.2 Архітектура IoT частини…………………………………………………..29
   2.3 Архітектура клієнтської частини…………………………………………35
3 Структура бази даних…………………………………………………………41
4 Опис програмної системи……………………………………………………..43
   4.1 Виклик і завантаження…………………………………………………….43
   4.2 Призначення і логічна структура…………………………………………43
   4.3 Опис програмної реалізації……………………………………………….45
Висновки…………………………………………………………………………54
Перелік джерел посилань……………………………………………………….55
Додаток А Результат перевірки на плагіат…………………………………….56
Додаток Б Код серверної частини……………………………………………..57
Додаток В Код IoT частини……………………………………………………68
Додаток Г Код клієнтської частини………………………………………………74
	

ВСТУП


У сучасному світі, де зміни клімату стають все більш відчутними, забезпечення оптимального мікроклімату в дитячих садках набуває стратегічного значення. Комфорт та безпека дітей під час їх перебування у дошкільних закладах є пріоритетом, що вимагає новаторського підходу до управління кліматом. Сучасні технології дозволяють реалізувати підходи, що враховують як поточні потреби, так і майбутні зміни.
Зі зростанням чисельності населення та підвищенням вимог до якості освітніх послуг, наявні системи управління кліматом у дитячих садках потребують модернізації. Непередбачувані погодні умови можуть негативно впливати на здоров’я та самопочуття дітей, що підкреслює необхідність ефективного моніторингу та регулювання внутрішнього клімату.
Розробка програмної системи управління кліматом в дитячих садках відповідає на ці виклики, пропонуючи інтегроване рішення для точного контролю температури, вологості та якості повітря. Це дозволяє створити ідеальні умови для розвитку та навчання дітей, а також сприяє збереженню енергії та ресурсів.
Застосування інформаційних технологій та автоматизованих систем управління дозволяє персоналу дитячих садків ефективно реагувати на зміни кліматичних умов, забезпечуючи стабільний та комфортний мікроклімат. Впровадження таких систем є важливим кроком на шляху до створення сталого та екологічно чистого майбутнього.
Це не лише підвищить якість освітнього процесу, але й сприятиме вихованню у дітей розуміння важливості енергоефективності та турботи про навколишнє середовище. Таким чином, ми забезпечуємо комфорт наших дітей сьогодні та закладаємо фундамент для більш здорового майбутнього.


1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1  Бізнес-можливості


За допомогою нашої програмної системи управління кліматом у дитячих садках, адміністрація може точно відстежувати та регулювати мікроклімат у приміщеннях, забезпечуючи оптимальні умови для здоров’я та комфорту дітей. Система дозволяє оптимізувати витрати на опалення, кондиціонування та вентиляцію, використовуючи дані про погодні умови та історичні показники. Також вона забезпечує контроль за виконанням робочих планів та задач, пов’язаних з утриманням приміщень, та автоматичне документування всіх процесів. Наша програмна система відповідає найвищим технічним вимогам, забезпечуючи швидкодію, масштабованість і надійність, що є критичними для успішної реалізації проекту. Наша програмна система інтегрується з іншими інформаційними системами, такими як системи безпеки, системи моніторингу енергоспоживання та інші, для забезпечення більшої ефективності та функціональності. Наша програмна система управління кліматом у дитячих садках відзначається численними перевагами порівняно з іншими аналогами, такими як Smart Climate Control, EcoVent та ClimateSmart Edu.
Почнемо з Smart Climate Control. Цей сервіс, як і наш, спрямований на забезпечення оптимального клімату в приміщеннях. Однак Smart Climate Control може мати обмеження, так як він може вимагати додаткового обладнання для повного функціоналу, а також може бути менш гнучким у використанні. Наша програмна система, натомість, пропонує інтегрований підхід з усіма необхідними функціями і забезпечує простий та зрозумілий інтерфейс, що полегшує його використання на будь-яких пристроях. 
Порівнюючи з EcoVent, який ставить акцент на енергоефективності, наш продукт відрізняється своїм широким спектром функцій управління кліматом. У той час як EcoVent може бути ефективним у збереженні енергії, він може бути менш гнучким у контролі та керуванні, що може бути не так важливим для користувачів, які шукають більш широкий спектр можливостей. 
Нарешті, ClimateSmart Edu, яка також пропонує рішення для управління кліматом у навчальних закладах. Вона забезпечує базовий контроль за температурою та вологістю, але наш продукт йде далі, пропонуючи повноцінний аналіз стану клімату з можливістю прогнозування та автоматизації, що є критично важливим для дитячих садків, де потрібен постійний моніторинг та реагування на зміни умов середовища. Наша програмна система дозволяє налаштовувати кліматичні умови відповідно до індивідуальних потреб кожного дитячого садка, забезпечуючи індивідуальні налаштування для різних приміщень. 
Програмний продукт орієнтується на ринок дитячих садків різного рівня та масштабу, які прагнуть підвищити якість своїх послуг та забезпечити комфорт та безпеку дітей. Зараз на ринку дитячих садків дійсно мало налагоджених систем управління кліматом, які повністю задовольняли б потреби цього сегмента. Більшість наявних систем зазвичай спрямовані на комерційні або житлові об'єкти і не завжди враховують специфічні вимоги дитячих садків. Недолік таких систем у тому, що вони не забезпечують повного контролю за кліматом, а також не враховують особливостей потреб дітей у здоровому та комфортному середовищі. Цей ринок є перспективним, оскільки дитячі садки є важливим елементом соціальної інфраструктури та забезпечують основу для розвитку дітей в ранньому віці. Зростає попит на інноваційні технології у сфері освіти та дитячого розвитку, що створює потенціал для впровадження нових рішень у цьому секторі. Наша програмна система управління кліматом у дитячих садках пропонуватиме різноманітні плани підписок, які надаватимуть користувачам доступ до широкого спектру функцій та можливостей. Ця модель монетизації дозволить нам забезпечити фінансову стабільність і розвиток продукту. Ми прагнемо запропонувати різні рівні підписок, щоб задовольнити потреби кожного закладу, від маленьких дитячих садочків до великих освітніх комплексів.


1.1.2  Бізнес-цілі та критерії успіху


БЦ-1: Забезпечити власникам та адміністрації дитячих садків доступ до надійної та актуальної інформації про кліматичні умови у приміщеннях, що допоможе їм забезпечити комфорт та безпеку дітей.
БЦ-2: Створити конкурентну перевагу на ринку освітніх технологій, використовуючи передові методи аналізу даних та IoT-застосунок , щоб забезпечити оптимальні умови для навчання та розвитку дітей.
БЦ-3: Розширити географію своєї діяльності, пропонуючи програмну систему управління кліматом в дитячих садках не лише в Україні, але й у інших країнах, що мають потенціал для розвитку дитячої освіти.
БЦ-4: Залучити нових клієнтів та партнерів, пропонуючи гнучкі тарифні плани, високий рівень сервісу та можливість інтеграції з іншими системами, щоб забезпечити оптимальне використання програмного продукту.
КУ-1: Набрати не менше 100 дитячих садків як активних користувачів програмної системи управління кліматом протягом першого року роботи.
КУ-2: Збільшити ефективність енергоспоживання на 20% протягом перших 12 місяців експлуатації системи.
КУ-3: Зменшити витрати на обслуговування та ремонт обладнання на 15% протягом першого року впровадження програми.
КУ-4: Забезпечити задоволеність не менше 95% клієнтів з умов проживання та безпеки дітей у дитячому садку.
КУ-5: Підвищити репутацію дитячого садка на місцевому ринку, отримавши позитивний відгук не менше ніж від 80% батьків.
КУ-6: Отримати позитивний фінансовий результат в кінці другого року роботи, покривши всі витрати на розробку, запуск та підтримку програмної системи.
КУ-7: Впровадити програмну систему управління кліматом в дитячих садках ще в трьох країнах протягом третього року роботи.
КУ-8: Стати лідером на ринку управління кліматом в дитячих садках в Україні та одним з провідних гравців у світі до п’ятого року роботи, отримавши високу оцінку від експертів та користувачів.


1.1.3  Потреби клієнта або ринку


Температурний комфорт і вологість: 
-	Дитячі садки потребують ефективного управління кліматом для забезпечення комфортних умов для дітей та персоналу, зокрема оптимальну температуру, вологість та повітряну якість.
Автоматизація процесів управління кліматом:
-	Клієнти вимагають систему, яка може автоматично регулювати кліматичні параметри в залежності від потреб, має можливість програмування графіків і реагує на зміни умов в реальному часі.
Енергоефективність:
-	Користувачі вимагають, щоб система складалася з енергоефективних компонентів та мала оптимізоване програмне забезпечення для зниження споживання енергії, що сприяє підвищенню загальної продуктивності системи. Крім того, енергоефективні рішення дозволяють продовжити термін служби обладнання та зменшити витрати на його охолодження та технічне обслуговування.
Інтеграція з іншими датчиками:
-	Клієнти очікують, що система буде сумісна з різними типами обладнання та легко інтегруватиметься з наявними системами управління. Важливо забезпечити безперебійну взаємодію нових рішень з уже наявними технологіями, щоб уникнути додаткових витрат на модернізацію чи заміну обладнання. Гнучкість і адаптивність системи гарантують її ефективну роботу в різних умовах та дозволяють максимально використовувати вже здійснені інвестиції в інфраструктуру.
Моніторинг та звітність:
-	Функціональність для відстеження стану системи та генерації звітів про її ефективність та використання ресурсів. Регулярні звіти допомагають керівництву приймати обґрунтовані рішення щодо управління кліматом та витратами.
Функції безпеки та автоматизації:
-	Наявність функцій сповіщень та автоматичного реагування на аномалії в кліматичних умовах є критичною для забезпечення безпеки та комфорту дітей.
Гнучкість і масштабованість:
-	Клієнти потребують рішення, яке може бути адаптоване до різних 
розмірів та конфігурацій приміщень. Система повинна мати можливість масштабування для розширення або зміни параметрів без значних додаткових витрат.


1.1.4	Бізнес-ризики
	
	
Ринкова конкуренція:
-	 Ринок рішень для управління кліматом насичений конкурентами, зокрема великі технологічні компанії та швидкозростаючі стартапи. Ці конкуренти можуть пропонувати більш інноваційні або дешевші продукти, що може ускладнити залучення нових клієнтів і утримання наявних. Агресивні маркетингові стратегії з боку конкурентів можуть знизити нашу ринкову частку. Для підтримання конкурентоспроможності нам потрібно постійно інвестувати у розвиток продукту та вдосконалювати маркетингові стратегії.
Невідповідність вимогам користувачів:
-	Успішний проект розробки програмного забезпечення вимагає точного розуміння та дотримання вимог користувачів. Невідповідність цим вимогам може призвести до невдоволення клієнтів, підвищення витрат на корекцію та затримок у реалізації проекту. Важливо почати з чіткого збору вимог за допомогою інтерв'ю, опитувань та аналізу даних. Регулярні перевірки, тісна взаємодія з користувачами та адаптація проекту відповідно до їхніх потреб є ключовими для запобігання невідповідностей. Постійний зворотний зв'язок та гнучкість у підходах забезпечать, що кінцевий продукт відповідатиме очікуванням користувачів і сприятиме досягненню їхніх цілей.
Обмеження в інвестиціях:
-	Недостатні фінансові ресурси можуть уповільнити розробку, впровадження та підтримку системи. Це може затримати розвиток нових функцій, обмежити маркетингові зусилля та знизити якість технічної підтримки, що поставить нас у несприятливе становище порівняно з фінансово більш забезпеченими конкурентами. Для подолання цих обмежень потрібно шукати додаткові джерела фінансування та ефективно використовувати наявні ресурси.
Ризик затримок у розробці та впровадженні:
-	Неочікувані технічні проблеми або складність інтеграції може призвести до затримок у розробці та впровадженні програмного продукту.
Юридичні ризики
-	Відсутність відповідності продукту юридичним вимогам може призвести до штрафів або заборони на використання системи в деяких регіонах. Необхідно ретельно слідкувати за змінами в законодавстві та забезпечувати відповідність всім необхідним стандартам і нормам.
Ризики безпеки даних
-	Ризик втрати або викрадення конфіденційної інформації через кіберзлочинність. Захист даних користувачів має бути на найвищому рівні для запобігання можливим порушенням безпеки та забезпечення довіри клієнтів.
Ризик недостатньої підтримки та навчання
-	Недостатня підтримка або відсутність ефективного навчання персоналу дитячих садків може призвести до неправильного використання системи та невдоволення користувачів. Важливо забезпечити якісне навчання та підтримку на всіх етапах впровадження та експлуатації.


1.2  Бачення рішення
1.2.1 Окреслення концепції


Даний продукт є ключовим для надання дитячим садкам інструменту для точного контролю клімату, забезпечуючи оптимальні умови для здоров’я та розвитку дітей. Впровадження програмної системи управління кліматом дозволить адміністрації дитячих садків ефективно керувати температурою та вологістю повітря, створюючи комфортне середовище для перебування дітей. Основні переваги цього продукту полягають у зменшенні зусиль та ресурсів, необхідних для підтримки ідеального клімату. Програмна система надає автоматизований механізм, який відстежує та регулює кліматичні умови, забезпечуючи стабільність температури та вологості. Це дозволяє зменшити витрати на опалення та кондиціонування, а також економить час та зусилля персоналу. 
Впровадження програмної системи управління кліматом допоможе дитячим садкам створити найкращі умови для розвитку дітей. Вони зможуть забезпечити регулярний контроль та налагодження кліматичних умов, покращити комфорт та здоров’я дітей. Крім того, це дозволить їм бути більш привабливими для батьків, привертати нових клієнтів та підвищувати репутацію закладу.
Програмна система управління кліматом у дитячих садках є інноваційним рішенням, яке допоможе оптимізувати умови перебування дітей у закладі та підвищити якість наданих послуг.


1.2.2  Головна функціональність


MF-1: Моніторинг температури у реальному часі
MF-2: Вимірювання та запис даних про вологість повітря
MF-3: Автоматичне налаштування кліматичного режиму
MF-4: Індивідуальні налаштування для кожного приміщення
MF-5: Автоматичне управління системами опалення та кондиціонування
MF-6: Сповіщення про відхилення від норми
MF-7: Збір та аналіз даних
MF-8: Адаптивне освітлення
MF-9: Планування режимів клімату
MF-10: Багаторівнева система доступу
MF-11: Моніторинг енергоспоживання та ефективності системи
MF-12: Автоматичне відключення системи у разі аварійних ситуацій
MF-13: Інтеграція з пожежною сигналізацією
MF-14: Контроль якості повітря
MF-15: Інтеграція з календарем
MF-16: Моніторинг шуму
MF-17: Автоматичне оновлення програмного забезпечення
MF-18: Автоматичне резервне копіювання даних та можливість відновлення.
MF-19: Шифрування даних для захисту конфіденційності користувачів.
MF-20: Аудит доступу та ведення журналу. 


1.2.3  Припущення і залежності


Залежність №1: Продукт буде корисний та затребуваний дитячими садками різного рівня та масштабу, які прагнуть створити оптимальні умови для розвитку дітей.
Залежність №2: Продукт матиме унікальну назву (ChildClimaCare) і тому користувач зможе легко знайти наш продукт у Інтернеті або на ринку освітніх технологій.
Залежність №3: Наш продукт зможе виконувати поставлені задачі, тільки при підключенні до мережі Інтернет.
Залежність №4: Швидкість оновлення інформації у нашому додатку залежатиме від завантаженості серверів, тому нам потрібно забезпечити стабільну інфраструктуру для забезпечення оптимальної продуктивності.
Залежність №5 Успішне впровадження системи управління кліматом буде залежати від наявності необхідного апаратного та програмного забезпечення, а також можливості користувачів використовувати сучасні пристрої.
Залежність №6: Розвиток системи управління кліматом може залежати від співпраці з освітніми організаціями, виробниками обладнання та органами державної влади для обміну даними та розширення функціональності продукту.
Припущення №1: Для роботи з нашим продуктом потрібно мати сучасний пристрій (комп’ютер, планшет, смартфон тощо), який підтримує веб-браузери та має достатню швидкість обробки даних.
Припущення №2: Для відповіді на поставлену задачу користувачем, нам потрібні потужні сервера та чітке з'єднання до мережі користувача.
Припущення №3: Передбачаємо, що наша система управління кліматом зацікавить не лише великі освітні комплекси, але і маленькі приватні дитячі садки.
Припущення №4: Зазначимо, що наш продукт повинен бути гнучким і здатним адаптуватися до різних кліматичних умов та потреб різних дитячих садків.
Припущення №5: Припускаємо, що користувачі мають базові технічні навички для роботи з комп’ютерами та сучасними мобільними пристроями.
Припущення №6: Передбачається, що система буде легко інтегрована з наявною інфраструктурою дитячих садків без необхідності значних змін.


1.3  Сфера застосування та обмеження
1.3.1  Рамки первинного випуску


Функціонал серверної частини:
-	Збір та обробка даних з датчиків: Система автоматично збиратиме дані з датчиків для моніторингу клімату.
-	Управління базою даних: Зберігання всіх історичних даних та звітів для подальшого аналізу.
-	Інтеграція з IoT-пристроями: Синхронізація з різними IoT- пристроями для збору даних та управління кліматом.
-	Логіка автоматичного регулювання клімату: Алгоритми для підтримки оптимального клімату в приміщенні.
-	Резервне копіювання: Користувачі зможуть зробити резервне копіювання та відновлення бази даних
-	Шифрування: Застосування протоколу HTTPS для забезпечення шифрування комунікацій.
-	Захист персональних даних: Збереження особистих даних буде враховувати вимоги стандартів безпеки, таких як GDPR, HIPAA
-	Адміністрування: Адміністратор може видаляти або блокувати облікові записи користувачів. Адміністратор налаштовує права та обмеження для кожної ролі. Адміністратор має можливість змінювати параметри облікових записів користувачів.
-	Управління бізнес логікою: Динамічне налаштування функцій та сутностей для адаптації до конкретних бізнес-вимог.
-	Інтеграція з пожежною сигналізацією: Автоматичне відключення системи у разі пожежної тривоги для забезпечення безпеки.
-	Математичні методи обробки даних: Розрахування теплового індексу та точки роси, використовуючи дані про температуру та вологість з датчиків.
	Функціонал клієнтської частини:
-	Інтерактивна панель керування: Користувачі зможуть переглядати та управляти кліматом через веб-інтерфейс.
-	Відображення реального часу даних: Перегляд актуальних даних з датчиків на панелі керування.
-	Графіки та аналітика: Аналіз кліматичних умов через графіки та звіти.
-	Користувацькі налаштування: Налаштування системи згідно з рівнем доступу користувача.
-	Локалізація: Система підтримує збереження даних у англійській та українських мовах. Користувач може вибрати мову інтерфейсу системи.
-	Реєстрація та авторизація: Створення сторінок та форм для реєстрації нових користувачів та входу в систему.
-	Перегляд клімату у кімнат: Користувачі зможуть переглядати стан клімату у кожній кімнаті
	Функціонал IoT-пристрою:
-	Інтеграція з датчиками: Збір даних з датчиків температури, вологості, CO2 для моніторингу.
-	Взаємодія з системами: Автоматичне управління опаленням, вентиляцією та кондиціонуванням.
-	Автоматичне регулювання освітлення: Налаштування освітлення в залежності від часу дня для створення оптимальних умов.
	Функціонал мобільного застосунку:
-	Push-сповіщення: Отримання сповіщень про важливі події та тривоги на мобільний пристрій.
-	Доступ до реального часу моніторингу: Відображення даних про кліматичні показники у режимі реального часу.
-	Керування налаштуваннями: Можливість коригування параметрів системи з мобільного пристрою.
-	Мобільні функції аналізу та відстеження даних: Доступ до аналітичних функцій та статистики з мобільного додатка.


1.3.2  Рамки наступних випусків

	
Функціонал мобільного застосунку:
-	Система сповіщень та тривог: Надсилання сповіщень у випадку виявлення проблем з кліматом.
-	Доступ до техпідтримки: Надання можливості звернутися за допомогою чи підтримкою з мобільного додатка.
Функціонал клієнтської частини:
-	Користувачі зможуть обмінюватися відгуками та коментарями, що підвищить якість обслуговування та співпраці в системі.
-	Машинне навчання для оптимізації енергоспоживання: Автоматичне регулювання енергоспоживання на основі аналізу поведінки користувачів та погодних умов.
-	Голосове управління: Впровадження можливості керування системою за допомогою голосових команд.
-	Інтеграція з календарем: Користувачі зможуть створювати календарний план
Функціонал серверної частини:
-	Інтеграція з іншими системами будівлі: Автоматизація взаємодії з системами безпеки, освітлення та іншими елементами інфраструктури.


1.3.3  Обмеження та винятки


-	Для ефективної роботи системи необхідне стабільне і швидке Інтернет-з'єднання. Обмеження в якості зв'язку або його відсутність може вплинути на здатність системи забезпечувати реальний час моніторингу та передавати дані користувачам. У першому випуску системи, інтерфейс користувача має бути доступним лише українською мовою. Можливість розширення на інші мови може бути розглянута у подальших випусках. 
-	Доступ до даних в системі має бути доступний лише авторизованим користувачам, які мають належні права доступу. Забезпечення безпеки даних є однією з основних пріоритетних задач.
-	Система працюватиме найкраще з сучасним обладнанням. Старіші моделі датчиків і пристроїв можуть не підтримуватися або потребувати додаткових налаштувань.
1.4  Бізнес-контекст
1.4.1  Профілі зацікавлених сторін


Таблиця 1.1 – Профілі зацікавлених сторін проекту

Зацікавлена сторона	
Головна цінність	
Ставлення	
Головний інтерес	
Обмеження
Адміністрація дитячих садків	Створення оптимального середовища для дітей	Зацікавлені у забезпеченні здоров’я та комфорту дітей	Підтримка стабільного та здорового клімату	Бюджетні обмеження, доступ до технологій
Вихователі та персонал	Зручність управління кліматом, ефективність роботи	Зацікавлені у підтримці комфортних умов праці	Легке та інтуїтивне управління системою	Необхідність навчання для використання системи
Батьки	Здоров’я та безпека дітей.	Зацікавлені у найкращих умовах для своїх дітей	Постійний моніторинг та контроль умов	Інформаційна прозорість та доступність
Розробник проекту	Реалізація технологічного рішення, дохід	Сильно зацікавлені у розробці та підтримці системи	Репутація, фінансовий успіх	Технічні виклики, вимоги замовника


1.4.2  Пріоритети проекту 


Таблиця 1.2 - Пріоритети проекту
Показник	Виконання 	Обмеження	Ступінь свободи

План робіт	Початковий випуск має бути
доступний
08.06.2024		 
Функціональність	 	Всі можливості
заплановано на
випуск 1.0 повинні
бути повністю працездатними	Не менше 80% від
високопріоритетних функцій
повинно бути включено в
початковий випуск
Якість	 		Перевірка на можливі баги/помилки повинні бути оброблені та виконані
Персонал		Максимальний розмір команди це 1 розробник та адміністратор	 
Ціна	 	Безкоштовно	


1.4.3  Операційне середовище


Даний продукт буде використовуватися через браузер на комп’ютері або за допомогою телефону та планшету. Для використання мобільного додатку має використовуватися система Android 11 та вище або iOS 14 та вище. Система використовує СУБД MongoDB для забезпечення ефективного зберігання та обробки даних. Серверна частина розробляється на мові C#, використовуючи .NET 6 та ASP.NET Core[1], а клієнтська частина використовує React для веб-клієнта. Для розробки мобільного застосунку буде використовуватися Kotlin та Android Studio. У системі також передбачено використання платформи Arduino для реалізації IoT-пристрою через симулятор WokWi. Цей стек технологій дозволяє побудувати продукт, який є легко масштабованим, розширюваним та підтримуваним. Завдяки ретельному вибору технологій і використанню готових бібліотек для інтеграції сторонніх сервісів, система може швидко вийти на ринок та взаємодіяти з іншими платформами.



2 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
2.1  Архітектура серверної частини


Архітектура серверної частини розроблена з урахуванням різних ролей(див рис 2.1 c.25), що беруть участь у взаємодії з нею: Користувач, Адміністратор Бізнес-логіки та Адміністратор Баз Даних. Кожна роль виконує свої унікальні дії, спрямовані на оптимальне використання системних можливостей.
Користувачі можуть виконувати такі дії, як реєстрація та авторизація, перегляд та додавання дитячих садків, фільтрація їх за категоріями, отримання рекомендацій та налаштування повідомлень. Ці функції забезпечують зручний доступ до необхідної інформації та покращують взаємодію з системою.
Адміністратор бізнес-логіки відповідає за управління користувачами та системою, зокрема налаштування прав та обмежень для різних користувачів, видалення та блокування записів. Це забезпечує контроль та безпеку доступу до системи, а також ефективне управління функціональністю.
Адміністратор баз даних займається адмініструванням баз даних, здійснює резервне копіювання, додає нові бази та забезпечує їх безпеку. Це гарантує збереження та цілісність даних, а також безперебійну роботу системи.


Рисунок 2.1 - Діаграма прецедентів серверної частини

Серверна частину була розроблена за технологією ASP.NET Core[2] на мові програмування C#.
Система використовує реляційну базу даних MongoDB для зберігання даних, отриманих від датчиків кімнат, а також інших системних та користувацьких даних. Складові бази даних забезпечують високий рівень надійності та швидкодії доступу до інформації. Також база даних буде з’єднана з ASP.NET Core за допомогою офіційного драйвера MongoDB для .NET.
Хешування паролів здійснюється за допомогою криптографічних хеш-функцій, такі як SHA-256 або SHA-3.
 Серверна частина складається з трьох компонентів(див рис 2.2 с.26): User-Interface, Web Server та Sensor. Усі вони пов’язані один з одним через протокол шифрування HTTPS. 
Сам ASP.NET Core використовує Route Handler для маршрутизації де URL-шляхи визначають, які сторінки або контролери повинні обслуговувати запит. Також сервер має модуль Middlewear для обробки запитів та подальшої передачі даних наступному компоненту.

 
Рисунок 2.2 – Діаграма розгортання серверної частини


Ключові кроки, які виконує користувач під час взаємодії з системою(див рис 2.3 c.28), тісно пов'язані з функціональністю серверної частини.
Процес починається з переходу користувача на сторінку авторизації, де він вводить своє ім'я користувача та пароль. Серверна частина перевіряє введені облікові дані, здійснюючи автентифікацію користувача. Якщо ім'я користувача або пароль невірний, сервер повертає користувача на сторінку авторизації з відповідним повідомленням про помилку.
Після успішної авторизації сервер надає користувачу доступ до основних функцій системи. Однією з ключових функцій є можливість перегляду кліматичних даних дитячого садка. Це включає взаємодію з базою даних MongoDB, де зберігаються всі дані, отримані від датчиків клімату. Сервер обробляє запити користувача та відображає актуальну інформацію про кліматичні умови в приміщеннях садка, зокрема температуру, вологість та інші параметри.
Протягом сесії користувач може отримувати додаткові рекомендації щодо оптимізації кліматичних умов. Ці рекомендації генеруються сервером на основі аналізу зібраних даних та встановлених правил. Сервер також забезпечує можливість фільтрації даних за різними критеріями, що дозволяє користувачу швидко знаходити потрібну інформацію.
Наприкінці сесії користувач може вибрати опцію виходу з облікового запису. Сервер обробляє запит на вихід, завершує активну сесію та забезпечує безпеку облікових даних, видаляючи всі тимчасові файли та дані сеансу.

 
Рисунок 2.3 – Діаграма взаємодії серверної частини


2.2  Архітектура IoT частини


Архітектура IoT частини системи управління кліматом у дитячих садках включає використання мікроконтролера ESP32 та трьох датчиків: DHT22, аналогового температурного датчика та фотодатчика. Кожен з цих датчиків виконує свою специфічну функцію, забезпечуючи збір важливих кліматичних даних.
DHT22 використовується для вимірювання вологості повітря. Цей датчик передає дані на ESP32 з високою точністю, що дозволяє контролювати рівень вологості у приміщеннях дитячого садка.
Аналоговий температурний датчик використовується для вимірювання температури. Він передає аналогові сигнали на ESP32, який перетворює їх у цифрові значення для подальшої обробки та передачі.
Фотодатчик використовується для вимірювання рівня освітленості. Дані з цього датчика дозволяють контролювати освітлення в приміщеннях, забезпечуючи комфортні умови для дітей.
Мікроконтролер ESP32(див рис 2.4, c.30) виконує роль центрального вузла, який збирає дані з усіх датчиків. Кожні 10 секунд ESP32 зчитує показники з датчиків і надсилає ці дані на сервер за допомогою HTTP-запиту. Після кожного успішного запиту ESP32 отримує статус підтвердження про запис даних, який відображається в консолі ESP32 для моніторингу.
Сервер обробляє отримані дані та записує їх до бази даних. Ця база даних дозволяє зберігати історичні дані для подальшого аналізу та використання в системі управління кліматом.


Рисунок 2.4 – Будова IoT-пристрою

IoT-система[4] розроблена з урахуванням ключових ролей(див рис 2.5, c.31), які взаємодіють з нею, зокрема користувача. Користувач може виконувати дії, такі як включення та вимкнення пристроїв, відправлення даних на сервер, додавання нових пристроїв, а також перегляд і зчитування даних пристроїв. Це дозволяє ефективно керувати живленням IoT-пристроїв, забезпечувати регулярну передачу даних з датчиків на сервер кожні 10 секунд за допомогою HTTP-запитів, масштабувати систему шляхом додавання нових датчиків, та отримувати актуальну інформацію про кліматичні умови у дитячих садках. Така архітектура забезпечує надійний збір, передачу та обробку даних, критично важливих для моніторингу та управління кліматом.
 
Рисунок 2.5 – Діаграма прецедентів IoT частини

Користувач взаємодіє з IoT-пристроєм через три основних компоненти(див рис 2.6, c.32): з'єднання до Wi-Fi, відправлення даних на сервер та отримання і відображення статусу даних. Першим кроком користувачу необхідно підключити пристрій до Wi-Fi. Якщо з'єднання не вдається, процес повторюється, доки не буде досягнуто успішного з'єднання. Після успішного з'єднання пристрій починає відправляти дані на сервер. Якщо сервер не може успішно обробити дані, цикл повторюється, поки дані не будуть успішно оброблені. Після успішної обробки даних сервером, статус обробки відображається на пристрої користувача. Користувач може зупинити процес або повторно надіслати запит на отримання даних. Ця архітектура забезпечує надійну передачу та обробку даних, що є критично важливим для ефективного моніторингу та управління кліматом у дитячих садках.
 
Рисунок 2.6 – Діаграма взаємодії користувача з IoT-пристроєм

Процес роботи пристрію(див рис 2.7, c.33) починається з активації пристрою. Після цього йде вимірювання показників вологості та температури. Якщо вимірювання були успішними, то відображається інформація про їх успішність. Далі йде повторення вимірювання. Після цього йде відображення самих даних та вимкнення пристрою. Якщо була помилка вимірювання, то процес повторюється.

 
Рисунок 2.7 – Діаграма станів IoT-пристрою

Для з’єднання з сервером сервер з початку підключається до Wi-Fi(див рис 2.8, c.34). У разі успішного з'єднання, пристрій переходить до передачі даних на сервер. Якщо передача даних не вдається, пристрій повторює спробу з'єднання до Wi-Fi. Після успішної передачі даних, починається запис даних до бази даних, після цього йде визначення статусу та запис статусу IoT-пристрою та даних. Після цього вже йде повернення статусу та відображення для IoT-пристрою. Після відображення статусу йде вимикання пристрію. 
 
Рисунок 2.8 – Діаграма діяльності IoT-пристрою
	

2.3   Архітектура клієнтської частини


Архітектура системи управління кліматом у дитячих садках складається з серверної та клієнтської частин. Клієнтська частина включає компоненти(див рис 2.9, c.36), такі як User.jsx, Gardens.jsx, Measurements.jsx, Register.jsx, Auth.jsx і Admin.jsx, які відповідають за відображення та взаємодію з користувачем. Кожен компонент виконує специфічні функції: управління профілем користувача, відображення інформації про дитячі садки, перегляд кліматичних показників, реєстрацію нових користувачів, авторизацію та адміністрування системи. Взаємодія з серверною частиною здійснюється через API, що забезпечує отримання та надсилання необхідної інформації. Процес починається з надсилання запиту з App.js до сервера, який обробляє запит і повертає результат для відображення у відповідному компоненті, забезпечуючи зручний інтерфейс для ефективного управління кліматом у дитячих садках.


Рисунок 2.9 – Діаграма компонентів клієнтської частини


Серверна частина взаємодіє з клієнтською за допомогою API[5](див рис 2.10, c.38). 
Компонент login відповідає за авторизацію користувача, взаємодіючи з client API для отримання введених користувачем даних, відправлення HTTP-запиту на сервер та очікування відповіді.
ChildClimaCare управляє кліматом, взаємодіючи з client API для отримання та надсилання даних на сервер, обробки та відображення результатів.
Компонент filter забезпечує фільтрацію даних, приймаючи фільтраційні параметри від користувача через client API, відправляючи їх на сервер та обробляючи отримані результати.
Компонент update відповідає за оновлення даних, взаємодіючи з client API для відправлення запиту на оновлення на сервер, обробки відповіді та оновлення відображених даних.
Компонент add дозволяє додавати нові дані, взаємодіючи з client API для відправлення нових даних на сервер та обробки результатів додавання.
Взаємодія між компонентами та їхні відносини здійснюються через client API та сервер. Кожен компонент генерує HTTP-запити до сервера відповідно до своїх функцій, сервер обробляє ці запити та надсилає відповіді, забезпечуючи ефективну роботу системи управління кліматом.


Рисунок 2.10 – Діаграма взаємодії клієнтської частини

Система забезпечує різноманітні шляхи взаємодії користувача з системою(див рис 2.11, c.40), зокрема як звичайних користувачів, так і адміністраторів.
Спочатку користувач знаходиться на головній сторінці, звідки він може перейти на сторінку реєстрації або авторизації. Після успішної реєстрації користувач повинен авторизуватися у системі. Після авторизації він переходить на сторінку з дитячими садками, де може переглядати інформацію про всі доступні садки.
Далі користувач може відкрити сторінку з кімнатами конкретного садка, де він зможе побачити всі кімнати цього закладу. На наступній сторінці користувач може переглянути інформацію про всі пристрої, що знаходяться у кімнатах.
Після цього користувач може переглянути всі записи пристроїв, що надають дані про кліматичні умови в кімнатах. На сторінці профілю користувач має можливість редагувати інформацію про свій обліковий запис.
Якщо користувач є адміністратором, він має доступ до сторінки адміністрування. На цій сторінці адміністратор може бачити всю інформацію про систему. Спочатку він може переглянути список всіх дитячих садків, які можна редагувати, видаляти та оновлювати. Потім адміністратор може переглянути списки всіх користувачів системи, кімнат, обладнання та даних з датчиків, з можливістю редагування, видалення та оновлення кожного елемента.


Рисунок 2.11 – Діаграма станів клієнтської частини

3 СТРУКТУРА БАЗИ ДАНИХ


Для розробки програмного продукту була використана база даних MongoDB. Використання документно-орієнтованої моделі даних дозволяє легко змінювати структуру збережених даних без необхідності складних міграцій. MongoDB забезпечує високу продуктивність і надійність, що є критично важливими для обробки великого обсягу даних, отриманих від численних сенсорів у реальному часі. Крім того, MongoDB добре підходить для обробки неструктурованих даних і підтримує високу швидкість зчитування і запису, що робить її ідеальною для застосування у системах з великим обсягом даних. Під час реалізації бази даних були створені наступні таблиці(див рис 3.1, c.42): 
-	User(Таблиця з даними користувача). Вона має такі поля: user_id, username, first_name, last_name, email, password, phone, role, status . Ця таблиця з’єднана з таблицею Gardens.
-	Gardens (Таблиця з садками та їх даними). Вона має такі поля: name, location, director, email, phone, users. Ця таблиця з’єднана з таблицею Users зв’язком один до багатьох та з таблицею Rooms зв’язком один до багатьох
-	Rooms(Таблиця з даними про кімнати). Вона має такі поля: room_number, capacity, garden_id. Ця таблиця з’єднана зв’язком один до багатьох та з таблицею Equipment
-	Equipment(Таблиця з даними про сенсори). Вона має такі поля: device_id, room_id, name, status. Ця таблиця з’єднана з таблицею Measurement зв’язком один до багатьох.
-	Measurement(Таблиця з обробленими даними). Вона має такі поля: measurement_id, device_id, measurement_type, measurement_value, measurement_time timestamp.
Кожен Садочок може мати одного або багато користувачів. Кожен садочок може мати одну або багато кімнат. Кожна кімната може мати одне або багато пристроїв зчитування даних. Кожен пристрій може мати багато записів даних.

 
Рисунок 3.1 – ER модель даних бази даних


4 ОПИС ПРОГРАМНОЇ СИСТЕМИ
4.1  Виклик і завантаження


Для того, щоб запустити програму спочатку її потрібно завантажити з усіма вихідними файлами. 
Для роботи з програмою потрібно мати останню версію СУБД MongoDB, встановлений npm[3] для запуску клієнту, ngrok для з’єднання з IoT-пристроєм та .NET SDK для серверної частини.
Спочатку користувачу потрібно виконати команду для відновлення залежностей “dotnet restore”, після цього він повинен запустити за допомогою команди “dotnet run” серверну частину.
Після цього потрібно встановити залежності за допомогою команди “npm install”, вже після цього користувач зможе запустити клієнтську частину за допомогою команди npm start, після якої користувач побачить інтерфейс системи.
Тепер для з’єднання з IoT-пристроєм потрібно запустити ngrok, це можно зробити за допомогою команди “ngrok http 5000”, де 5000 – порт вашого серверу, після цього з’явиться URL адреса для IoT-пристрою.


4.2  Призначення і логічна структура 


Ця система призначена для зручного моніторингу клімату в дитячих садках. 
Система розподілена на 7 модулей:
-	Модуль "Садки": Цей модуль дозволяє адміністрації управляти даними про дитячі садки, зокрема назви, місцезнаходження, контактні дані та відповідальних осіб. Модуль забезпечує централізоване зберігання та доступ до інформації про всі садки, підключені до системи.
-	Модуль "Кімнати": Даний модуль відповідає за управління та моніторинг кімнат у кожному дитячому садку. Він дозволяє відстежувати номер кімнати, її місткість та призначення, а також забезпечує інтеграцію з датчиками, встановленими в кожній кімнаті.
-	Модуль "Обладнання": Цей модуль включає управління різними типами кліматичного обладнання, встановленого в кімнатах. Кожен пристрій має унікальний ідентифікатор, статус та розміщення у певній кімнаті. Модуль забезпечує централізований контроль та управління усіма підключеними пристроями.
-	Модуль "Дані з датчиків": Модуль забезпечує постійний збір та обробку даних з датчиків, встановлених у приміщеннях. Дані включають показники температури, вологості, рівня CO2 та освітленості, що дозволяє відстежувати поточні кліматичні умови та аналізувати їх у реальному часі.
-	Модуль "Керування датчиками": Даний модуль використовує зібрані дані для автоматичного регулювання роботи кліматичного обладнання. Це дозволяє підтримувати оптимальні кліматичні умови у приміщеннях у режимі реального часу, забезпечуючи здорове середовище для дітей.
-	Модуль "Сповіщення": Модуль генерує сповіщення у випадку відхилення кліматичних умов від заданих параметрів. Це дозволяє адміністрації дитячого садка оперативно реагувати на потенційні проблеми та вживати необхідних заходів для їх усунення.

4.3  Опис програмної реалізацї


При запуску системи користувач потрапляє на головну сторінку(див рис 4.1, c.45), де він зможе побачити вибір мови та іконку профілю при натисканні якої він побачить меню(див рис 4.2, c.45).

 
Рисунок 4.1 – Головна сторінка 

 
Рисунок 4.2 – Меню

На цьому меню користувач побачить 4 кнопки:
-	Main для повернення на головну сторінку.
-	Registration для переходу на сторінку реєстрації
-	Authorization для переходу на сторінку авторизації
-	Close для закриття меню
Після натискання на кнопку "Реєстрація" користувач переходить на сторінку реєстрації(див рис 4.3, c.46), на якій йому потрібно ввести свої дані у поля.
 
Рисунок 4.3 – Сторінка реєстрації

Після успішної реєстрації користувач повинен перейти на сторінку авторизації(див рис 4.4, c.47).
 
Рисунок 4.4 – Сторінка авторизації

Після успішної авторизації, якщо користувач працює в садочку, то він потрапить на сторінку свого садочку(див рис 4.5, c.48). Якщо ні, то він потрапить на сторінку де буде написано, що ви не являєтесь працівником(див рис 4.6, c.48).
 
Рисунок 4.5 – Сторінка с садочком для працівника

 
Рисунок 4.6 – Сторінка садочку для не працівника садочку

Після цього працівник садочку зможе перейти на сторінку своїх кімнат(див рис 4.7, c.49), де він зможе створювати, видаляти кімнати, фільтрувати кімнати за кількістю дітей та шукати за номером.
 
Рисунок 4.7 – Сторінка кімнат садочку

Після цього користувач може нажати на кнопку обладнання, де він перейде на сторінку з обладнанням(див рис 4.8, c.50), на тій сторінці він може редагувати, видаляти та додавати нові обладнання, також він може шукати їх за назвою, сортувати за статусом та вимикати або вмикати обладнання.

 
Рисунок 4.8 – Сторінка обладнання

Після цього користувач може перейти на сторінку вимірювання(див рис 4.9, c.51), де він зможе керувати усіма вимірюваннями з датчиків, зокрема температурою та вологістю. Тут він також зможе шукати їх за типом та фільтрувати за значенням.
 
Рисунок 4.9 – Сторінка з вимірами

Якщо користувачу потрібно змінити свої дані, в меню він може перейти на сторінку облікового запису(див рис 4.10, c.52), де він зможе редагувати свої дані.
 
Рисунок 4.10 – Сторінка налаштувань користувача на українській

Користувач також може змінювати мову інтерфейсу завдяки кнопці (див рис 4.11, c.52) в меню, після якої мова інтерфейсу буде змінена(див рис 4.12, c.53).

 
Рисунок 4.11 – Кнопка для зміни мови


Рисунок 4.12 - Сторінка налаштувань користувача на англійській мові

Якщо користувач завершив сеанс, то він може натиснути на кнопку Вийти в меню, після чого він вийде з системи та повернеться на головну сторінку.



ВИСНОВКИ


Під час виконання курсового проекту було створено програмну систему для управління кліматом в дитячих садках. 
Під час розробки було проведено аналіз предметної області, побудова архітектури системи, створення бази даних та опис програмної системи.
Система була розроблена з використанням сучасних технологій і підходів. Система може використовуватися через браузер на комп’ютері. Система використовує СУБД MongoDB для ефективного зберігання та обробки даних. Серверна частина розроблена на мові C#, використовуючи .NET 6 та ASP.NET Core, а клієнтська частина використовує React для веб-клієнта.
У системі також передбачено використання платформи Arduino для реалізації IoT-пристрою через симулятор WokWi. Цей стек технологій дозволяє побудувати продукт, який є легко масштабованим[6], розширюваним та підтримуваним. Завдяки ретельному вибору технологій і використанню готових бібліотек для інтеграції сторонніх сервісів, система може швидко вийти на ринок та взаємодіяти з іншими платформами.
Запроваджена система[8] дозволяє здійснювати моніторинг та управління кліматичними умовами у дитячих садках у режимі реального часу. Завдяки автоматичному збору та обробці даних з датчиків, система забезпечує оптимальні умови для перебування дітей, що позитивно впливає на їхнє здоров'я та комфорт. Система також допомагає оптимізувати використання енергії, що сприяє зниженню витрат та підвищенню енергоефективності закладу.



ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАНЬ


1. Адам Фрімен Pro ASP.NET Core 3. Apress, 2019. – 1058 с.
2. Документація ASP.NET Core. URL: https://docs.microsoft.com/en-us/aspnet/core (дата звернення: 13.04.2024).
3. Документація React. URL: https://reactjs.org (дата звернення: 16.05.2023).
4. Документація симулятора Wokwi IoT. URL: https://docs.wokwi.com (дата звернення: 03.05.2024).
5. Документація API RESTful. URL: https://restfulapi.net (дата звернення: 13.04.2024).
6. Еріх Гамма, Річард Хелм, Ральф Джонсон, Джон Вліссідес. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley Professional, 1994. – 395 с.
7. Посилання на Github репозиторій. URL: https://github.com/NureMartynovArsenii/apzkr-pzpi-21-8-martynov-arsenii
8. Посилання на функціональне тестування системи URL: https://www.youtube.com/watch?v=SUWxkMb4Qso

ДОДАТОК А
Результат перевірки на плагіат

Рисунок A.1 – Знімок екрану перевірки на плагіат

ДОДАТОК Б
Код серверної частини


Код головного файлу Program.cs
1   var builder = WebApplication.CreateBuilder(args);

2   var configuration = new ConfigurationBuilder()
3       .SetBasePath(Directory.GetCurrentDirectory())
4       .AddJsonFile("appsettings.json")
5       .Build();

6   builder.Services.AddSingleton<IMongoClient>(provider =>
7   {
8       var connectionString = configuration.GetConnectionString("MongoDB");
9       return new MongoClient(connectionString);
10  });

11  builder.Services.AddScoped(provider =>
12  {
13      var client = provider.GetRequiredService<IMongoClient>();
14      var databaseName = configuration.GetValue<string>("DatabaseSettings:DatabaseName");
15      return client.GetDatabase(databaseName);
16  });

17  builder.Services.AddScoped<IAdminUserRepository, AdminUserRepository>();
18  builder.Services.AddScoped<IGardenRepository, GardenRepository>();
19  builder.Services.AddScoped<IEquipmentRepository, EquipmentRepository>();
20  builder.Services.AddScoped<IMeasurementRepository, MeasurementRepository>();
21  builder.Services.AddScoped<IRoomRepository, RoomRepository>();
22  builder.Services.AddScoped<IUserRepository, UserRepository>();

23  builder.Services.AddScoped<IAdminUserService, AdminUserService>();
24  builder.Services.AddScoped<IGardenService, GardenService>();
25  builder.Services.AddScoped<IEquipmentService, EquipmentService>();
26  builder.Services.AddScoped<IMeasurementService, MeasurementService>();
27  builder.Services.AddScoped<IRoomService, RoomService>();
28  builder.Services.AddScoped<IUserService, UserService>();
29  builder.Services.AddScoped<ITokenService, TokenService>();
30  builder.Services.AddControllers();
31 builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
32      .AddJwtBearer(options =>
33      {
34          options.TokenValidationParameters = new TokenValidationParameters
35          {
36              ValidateIssuer = true,
37              ValidateAudience = true,
38              ValidateLifetime = true,
39              ValidateIssuerSigningKey = true,
40              ValidIssuer = configuration["Jwt:Issuer"],
41              ValidAudience = configuration["Jwt:Audience"],
42              IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration["Jwt:Key"]))
43          };
44      });
45  builder.Services.AddAuthorization(options =>
46  {
47      options.AddPolicy("AdminOnly", policy => policy.RequireRole("admin"));
48      options.AddPolicy("EmployeeOnly", policy => policy.RequireRole("employee"));
49  });
50  builder.Services.AddCors(options =>
51  {
52      options.AddPolicy("AllowReactApp",
53          policy =>
54          {
55              policy.WithOrigins("http://localhost:3000") 
56                    .AllowAnyHeader()
57                    .AllowAnyMethod();
58          });
59  });
60  var app = builder.Build();
61  app.UseCors("AllowReactApp");
62  app.UseAuthentication();
63  app.UseAuthorization();
64  app.MapGet("/", () => "Hello World!");
65  app.MapControllers();
66  app.Run();

Код AdminController.cs
1   [Route("api/admin")]
2   [ApiController]
3   public class AdminController : ControllerBase
4   {
5       private readonly IAdminUserService _adminUserService;
6       private readonly ITokenService _tokenService;
7       private readonly IGardenService _gardenService;
8       private readonly IRoomService _roomService;
9       private readonly IEquipmentService _equipmentService;
10      private readonly IMeasurementService _measurementService;
11      public AdminController(IAdminUserService adminUserService, ITokenService tokenService, IGardenService gardenService, IRoomService roomService,
12          IEquipmentService equipmentService,
13          IMeasurementService measurementService)
14      {
15          _adminUserService = adminUserService;
16          _tokenService = tokenService;
17          _gardenService = gardenService;
18          _roomService = roomService;
19          _equipmentService = equipmentService;
20          _measurementService = measurementService;
21      }
22      [HttpPost("login")]
23      public async Task<IActionResult> Login([FromBody] LoginModel loginModel)
24      {
25          var adminUser = await _adminUserService.GetByUsernameAsync(loginModel.Username);

26          if (adminUser == null || adminUser.Password != loginModel.Password) 
27          {
28              return Unauthorized("Invalid username or password.");
29          }
30          var token = _tokenService.GenerateToken(adminUser);
31          return Ok(new { token, role = adminUser.Role });
32      }
33      [Authorize(Policy = "AdminOnly")]
34      [HttpGet("Users")]
35      public async Task<ActionResult<List<AdminUser>>> GetAllUsers()
36      {
37          var users = await _adminUserService.GetAllUsersAsync();
38          return Ok(users);
39      }
40      [Authorize(Policy = "AdminOnly")]
41      [HttpGet("Users/{id:length(24)}")]
42      public async Task<ActionResult<AdminUser>> GetUserById(string id)
43      {
44          var user = await _adminUserService.GetUserByIdAsync(id);
45          if (user == null)
46          {
47              return NotFound("Користувача з таким ID не знайдено.");
48          }
49          return Ok(user);
50      }
51      [Authorize(Policy = "AdminOnly")]
52      [HttpPost("Users")]
53      public async Task<IActionResult> CreateUser([FromBody] AdminUser adminUser)
54      {
55          if (adminUser.Id != null)
56          {
57              adminUser.Id = null; 
58          }
59          await _adminUserService.CreateUserAsync(adminUser);
60          return CreatedAtAction(nameof(GetUserById), new { id = adminUser.Id }, adminUser);
61      }
62      [Authorize(Policy = "AdminOnly")]
63      [HttpPut("Users/{id:length(24)}")]
64      public async Task<IActionResult> UpdateUser(string id, [FromBody] AdminUserUpdateModel adminUserUpdateModel)
65      {
66          await _adminUserService.UpdateUserAsync(id, adminUserUpdateModel);
67          return Ok("Інформація про користувача оновлена успішно.");
68      }
69      [Authorize(Policy = "AdminOnly")]
70      [HttpDelete("Users/{id:length(24)}")]
71      public async Task<IActionResult> DeleteUser(string id)
72      {
73          await _adminUserService.DeleteUserAsync(id);
74          return Ok("Користувача успішно видалено.");
75      }
76      [Authorize(Policy = "AdminOnly")]
77      [HttpGet("Gardens")]
78      public async Task<ActionResult<List<Garden>>> GetAllGardens()
79      {
80          var gardens = await _gardenService.GetAllAsync();
81          return Ok(gardens);
82      }
83      [Authorize(Policy = "AdminOnly")]
84      [HttpGet("Gardens/{id:length(24)}")]
85      public async Task<ActionResult<Garden>> GetGarden(string id)
86      {
87          var garden = await _gardenService.GetByIdAsync(id);
88          if (garden == null)
89          {
90              return NotFound();
91          }
92          return Ok(garden);
93      }
94      [Authorize(Policy = "AdminOnly")]
95      [HttpPost("Gardens")]
96      public async Task<IActionResult> CreateGarden([FromBody] GardenCreateModel gardenCreateModel)
97      {
98          if (gardenCreateModel.Users != null)
99          {
100             foreach (var user in gardenCreateModel.Users)
101             {
102                 if (!ObjectId.TryParse(user.Id, out _))
103                 {
104                     return BadRequest($"Invalid user ID: {user.Id}");
105                 }
106             }
107         }
108         await _gardenService.CreateAsync(gardenCreateModel);
109         return Ok("Садок створено успішно.");
110     }
111     [Authorize(Policy = "AdminOnly")]
112     [HttpPut("Gardens/{id:length(24)}")]
113     public async Task<IActionResult> UpdateGarden(string id, [FromBody] GardenUpdateModel gardenUpdateModel)
114     {
115         if (gardenUpdateModel.Users != null)
116         {
117             foreach (var user in gardenUpdateModel.Users)
118             {
119                 if (!ObjectId.TryParse(user.Id, out _))
120                 {
121                     return BadRequest($"Invalid user ID: {user.Id}");
122                 }
123             }
124         }
125         await _gardenService.UpdateAsync(id, gardenUpdateModel);
126         return Ok("Інформація про садок оновлена успішно.");
127     }
128     [Authorize(Policy = "AdminOnly")]
129     [HttpDelete("Gardens/{id:length(24)}")]
130     public async Task<IActionResult> DeleteGarden(string id)
131     {
132         await _gardenService.DeleteAsync(id);
133         return Ok("Садок видалено успішно.");
134     }
135     [Authorize(Policy = "AdminOnly")]
136     [HttpGet("Rooms")]
137     public async Task<ActionResult<List<Room>>> GetAllRooms()
138     {
139         var rooms = await _roomService.GetAllAsync();
140         // Fetch garden names and attach to rooms
141         var gardens = await _gardenService.GetAllAsync();
142         var gardenDict = gardens.ToDictionary(g => g.Id, g => g.Name);
143         foreach (var room in rooms)
144         {
145             if (gardenDict.ContainsKey(room.GardenId))
146             {
147                 room.GardenName = gardenDict[room.GardenId];
148             }
149         }
150         return Ok(rooms);
151     }
152     [Authorize(Policy = "AdminOnly")]
153     [HttpGet("Rooms/{id:length(24)}", Name = "AdminGetRoom")]
154     public async Task<ActionResult<Room>> GetRoomById(string id)
155     {
156         var room = await _roomService.GetByIdAsync(id);
157         if (room == null)
158         {
159             return NotFound("Room with this ID not found.");
160         }
161         var garden = await _gardenService.GetByIdAsync(room.GardenId);
162         room.GardenName = garden?.Name;
163         return Ok(room);
164     }
165     [Authorize(Policy = "AdminOnly")]
166     [HttpGet("Rooms/{id:length(24)}/equipment")]
167     public async Task<ActionResult<List<Equipment>>> GetEquipmentByRoomId(string id)
168     {
169         var equipment = await _equipmentService.GetByRoomIdAsync(id);
170         return Ok(equipment);
171     }
172     [Authorize(Policy = "AdminOnly")]
173     [HttpDelete("Rooms/{id:length(24)}")]
174     public async Task<IActionResult> DeleteRoom(string id)
175     {
176         await _roomService.DeleteAsync(id);
177         return Ok("Room deleted successfully.");
178     }
179     [Authorize(Policy = "AdminOnly")]
180     [HttpPost("Rooms")]
181     public async Task<IActionResult> CreateRoom([FromBody] RoomCreateModel roomCreateModel)
182     {
183         var createdRoom = await _roomService.CreateAsync(roomCreateModel);
184         return CreatedAtAction(nameof(GetRoomById), new { id = createdRoom.Id }, createdRoom);
185     }
186     [Authorize(Policy = "AdminOnly")]
187     [HttpPut("Rooms/{id:length(24)}")]
188     public async Task<IActionResult> UpdateRoom(string id, [FromBody] RoomUpdateModel roomUpdateModel)
189     {
190         await _roomService.UpdateAsync(id, roomUpdateModel);
191         return Ok("Room updated successfully.");
192     }

193     [Authorize(Policy = "AdminOnly")]
194     [HttpGet("Equipment")]
195     public async Task<ActionResult<List<Equipment>>> GetAllEquipments()
196     {
197         var equipments = await _equipmentService.GetAllAsync();
198         return Ok(equipments);
199     }
200     [Authorize(Policy = "AdminOnly")]
201     [HttpGet("Equipment/{id:length(24)}", Name = "AdminGetEquipment")]
202     public async Task<ActionResult<Equipment>> GetEquipmentById(string id)
203     {
204         var equipment = await _equipmentService.GetByIdAsync(id);
205         if (equipment == null)
206         {
207             return NotFound("Equipment with this ID not found.");
208         }
209         return Ok(equipment);
210     }
211     [Authorize(Policy = "AdminOnly")]
212     [HttpGet("Equipment/{id:length(24)}/measurements")]
213     public async Task<ActionResult<List<Measurement>>> GetMeasurementsByEquipmentId(string id)
214     {
215         var measurements = await _measurementService.GetByDeviceIdAsync(id);
216         return Ok(measurements);
217     }
218     [Authorize(Policy = "AdminOnly")]
219     [HttpDelete("Equipment/{id:length(24)}")]
220     public async Task<IActionResult> DeleteEquipment(string id)
221     {
222         await _equipmentService.DeleteAsync(id);
223         return Ok("Equipment deleted successfully.");
224     }
225     [Authorize(Policy = "AdminOnly")]
226     [HttpPost("Equipment")]
227     public async Task<IActionResult> CreateEquipment([FromBody] EquipmentCreateModel equipmentCreateModel)
228     {
229         var createdEquipment = await _equipmentService.CreateAndGetAsync(equipmentCreateModel);
230         return CreatedAtRoute("AdminGetEquipment", new { id = createdEquipment.Id }, createdEquipment);
231     }
232     [Authorize(Policy = "AdminOnly")]
233     [HttpPut("Equipment/{id:length(24)}")]
234     public async Task<IActionResult> UpdateEquipment(string id, [FromBody] EquipmentUpdateModel equipmentUpdateModel)
235     {
236         await _equipmentService.UpdateAsync(id, equipmentUpdateModel);
237         return Ok("Equipment updated successfully.");
238     }
239     // Measurement Management
240     [Authorize(Policy = "AdminOnly")]
241     [HttpGet("Measurements")]
242     public async Task<ActionResult<List<Measurement>>> GetAllMeasurements()
243     {
244         var measurements = await _measurementService.GetAllAsync();
245         return Ok(measurements);
246     }
247     [Authorize(Policy = "AdminOnly")]
248     [HttpGet("Measurements/{id:length(24)}", Name = "AdminGetMeasurement")]
249     public async Task<ActionResult<Measurement>> GetMeasurementById(string id)
250     {
251         var measurement = await _measurementService.GetByIdAsync(id);
252         if (measurement == null)
253         {
254             return NotFound("Measurement with this ID not found.");
255         }
256         return Ok(measurement);
257     }
258     [Authorize(Policy = "AdminOnly")]
259     [HttpDelete("Measurements/{id:length(24)}")]
260     public async Task<IActionResult> DeleteMeasurement(string id)
261     {
262         await _measurementService.DeleteAsync(id);
263         return Ok("Measurement deleted successfully.");
264     }

265     [Authorize(Policy = "AdminOnly")]
266     [HttpPost("Measurements")]
267     public async Task<IActionResult> CreateMeasurement([FromBody] MeasurementCreateModel measurementCreateModel)
268     {
269         var createdMeasurement = await _measurementService.CreateAndGetAsync(measurementCreateModel);
270         if (createdMeasurement == null)
271         {
272             return StatusCode(500, "An error occurred while creating the measurement.");
273         }
274         return CreatedAtRoute("AdminGetMeasurement", new { id = createdMeasurement.Id }, createdMeasurement);
275     }
276     [Authorize(Policy = "AdminOnly")]
277     [HttpPut("Measurements/{id:length(24)}")]
278     public async Task<IActionResult> UpdateMeasurement(string id, [FromBody] MeasurementUpdateModel measurementUpdateModel)
279     {
280         await _measurementService.UpdateAsync(id, measurementUpdateModel);
281         return Ok("Measurement updated successfully.");
282     }
283     [Authorize(Policy = "AdminOnly")]
284     [HttpPost("start")]
285     public IActionResult StartMeasurement()
286     {
287         _measurementService.StartMeasurement();
288         return Ok(new { Message = "Measurement started" });
289     }
290     [Authorize(Policy = "AdminOnly")]
291     [HttpPost("stop")]
292     public IActionResult StopMeasurement()
293     {
294         _measurementService.StopMeasurement();
295         return Ok(new { Message = "Measurement stopped" });
296     }

297     [Authorize(Policy = "AdminOnly")]
298     [HttpGet("status")]
299     public IActionResult GetMeasurementStatus()
300     {
301         var status = _measurementService.IsMeasuring();
302         return Ok(new { IsMeasuring = status });
303     }
304 }

ДОДАТОК В
Код IoT частини

Код main.ino
1  #include <Arduino.h>
2  #include <WiFi.h>
3  #include <WebServer.h>
4  #include <HTTPClient.h>
5  #include <ArduinoJson.h>
6  #include "WiFiManager.h"
7  #include "SensorManager.h"
8  #include "DataSender.h"
9  #include "Config.h"
10 #include "DebugManager.h"
11 
12 const char* ssid = "Wokwi-GUEST";
13 const char* password = "";
14 String jwtToken = ""; 
15 
16 SensorManager sensorManager;
17 DataSender dataSender;
18 DebugManager debugManager;
19 WebServer server(80);
20 
21 bool isMeasuring = false; 
22 bool isMeasuringInitialized = false; 
23 
24 void handleToken() {
25     if (server.hasArg("token")) {
26         jwtToken = server.arg("token");
27         server.send(200, "text/plain", "Token received");
28         Serial.println("Received token: " + jwtToken);
29     } else {
30         server.send(400, "text/plain", "Token not received");
31     }
32 }
33 
34 void setup() {
35     Serial.begin(9600);
36     WiFiManager::connect(ssid, password);
37     debugManager.begin();
38 
39     server.on("/token", handleToken); 
40     server.begin();
41     Serial.println("HTTP server started");
42 
43     
44     getToken();
45 }
46 
47 void loop() {
48     server.handleClient(); // Обробка клієнтів
49     if (jwtToken != "") {
50         checkMeasurementStatus(); // Перевірка статусу вимірювань
51         // Якщо вимірювання включено, виконуємо вимірювання
52         if (isMeasuringInitialized && isMeasuring) {
53             performMeasurements();
54             delay(10000); 
55         } else {
56             Serial.println("Measurement is not active.");
57             delay(5000); 
58         }
59     } else {
60         Serial.println("JWT token is empty, trying to get a new one...");
61         getToken();
62     }
63 }
64 
65 void performMeasurements() {
66     debugManager.logStatus("Starting new measurement cycle");
67 
68     float lux = sensorManager.readLightIntensity();
69     if (!isnan(lux)) {
70         Serial.print("Lux: ");
71         Serial.println(lux);
72         dataSender.sendSensorData("LightIntensity", lux);
73         debugManager.logData("LightIntensity", lux);
74     } else {
75         debugManager.logError("Failed to read light intensity");
76     }
77 
78     float temp = sensorManager.readTemperature();
79     if (!isnan(temp)) {
80         Serial.print("Temperature: ");
81         Serial.print(temp);
82         Serial.println(" ℃");
83         dataSender.sendSensorData("Temperature", temp);
84         debugManager.logData("Temperature", temp);
85     } else {
86         debugManager.logError("Failed to read temperature");
87     }
88 
89     float humidity = sensorManager.readHumidity();
90     if (!isnan(humidity)) {
91         Serial.print("Humidity: ");
92         Serial.println(humidity);
93         dataSender.sendSensorData("Humidity", humidity);
94         debugManager.logData("Humidity", humidity);
95     } else {
96         debugManager.logError("Failed to read humidity");
97     }
98 
99     debugManager.logStatus("Finished measurement cycle");
100 }
101 
102 void getToken() {
103     if (WiFi.status() == WL_CONNECTED) {
104         HTTPClient http;
105         http.begin("http://2524-2a03-7380-238a-357-906c-3064-56c5-c549.ngrok-free.app/api/admin/login"); 
106         http.addHeader("Content-Type", "application/json");
107 
108         // Створюємо JSON для авторизації
109         String requestBody = "{\"username\":\"ClimateAdmin\",\"password\":\"climateadmin123\"}";
110         int httpResponseCode = http.POST(requestBody);
111 
112         if (httpResponseCode > 0) {
113             String response = http.getString();
114             Serial.println(httpResponseCode);
115             Serial.println(response);
116 
117             StaticJsonDocument<200> jsonDoc;
118             deserializeJson(jsonDoc, response);
119             jwtToken = jsonDoc["token"].as<String>();
120             Serial.println("JWT Token: " + jwtToken);
121         } else {
122             Serial.print("Error on getting token: ");
123             Serial.println(httpResponseCode);
124         }
125 
126         http.end();
127     } else {
128         Serial.println("Error in WiFi connection");
129     }
130 }
131 
132 void checkMeasurementStatus() {
133     Serial.println("Checking measurement status...");
134     Serial.println("WiFi status: " + String(WiFi.status() == WL_CONNECTED ? "Connected" : "Disconnected"));
135     Serial.println("JWT Token: " + jwtToken);
136 
137     if (WiFi.status() == WL_CONNECTED && jwtToken != "") {
138         HTTPClient http;
139         http.begin("http://2524-2a03-7380-238a-357-906c-3064-56c5-c549.ngrok-free.app/api/admin/status");
140         http.addHeader("Authorization", "Bearer " + jwtToken); // Додавання заголовку авторизації
141         int httpResponseCode = http.GET();
142 
143         if (httpResponseCode > 0) {
144             String response = http.getString();
145             Serial.println(httpResponseCode);
146             Serial.println(response);
147 
148             StaticJsonDocument<200> jsonDoc;
149             deserializeJson(jsonDoc, response);
150             bool newIsMeasuring = jsonDoc["isMeasuring"]; 
151             
152           
153             isMeasuring = newIsMeasuring;
154             isMeasuringInitialized = true; 
155             if (isMeasuring) {
156                 Serial.println("Measurement started");
157             } else {
158                 Serial.println("Measurement stopped");
159             }
160         } else {
161             Serial.print("Error on getting status: ");
162             Serial.println(httpResponseCode);
163         }
164 
165         http.end();
166     } else {
167         Serial.println("Error in WiFi connection or JWT token is empty");
168     }
169 }


Код SensorManager.cpp
1  #include "SensorManager.h"
2  #include "Config.h"
3  #include <ArduinoJson.h>
4  #include <DHT.h>
5  #include <math.h>
6  
7  DHT dht(DHT_PIN, DHT22);
8  
9  SensorManager::SensorManager() {
10     analogReadResolution(10);
11     pinMode(NTC_PIN, INPUT);
12     pinMode(PHOTOSENSOR_PIN, INPUT);
13     dht.begin();
14 }
15 
16 float SensorManager::readLightIntensity() {
17     int lightValue = analogRead(PHOTOSENSOR_PIN);
18     float voltage = lightValue / 1024.0 * 5.0;
19     float resistance = 2000 * voltage / (1 - voltage / 5.0);
20     float lux = pow(RL10 * 1e3 * pow(10, GAMMA) / resistance, (1 / GAMMA));
21     return isnan(lux) ? 0 : lux;
22 }
23 
24 float SensorManager::readTemperature() {
25     int adcValue = analogRead(NTC_PIN);
26     if (adcValue <= 1) {
27         Serial.println("NTC read error");
28         return NAN;
29     }
30     float celsius = 1 / (log(1 / (1023.0 / adcValue - 1)) / BETA + 1.0 / 298.15) - 273.15;
31     return isnan(celsius) ? NAN : celsius;
32 }
33 
34 float SensorManager::readHumidity() {
35     float humidity = dht.readHumidity();
36     return isnan(humidity) ? NAN : humidity;
37 }

ДОДАТОК Г
Код клієнтської частини

Код Garden.js
1  import React, { useEffect, useState } from 'react';
2  import { useTranslation } from 'react-i18next';
3  import { useNavigate } from 'react-router-dom';
4  import FullScreenImage from './FullScreenImage'; 
5  
6  const Gardens = () => {
7      const { t } = useTranslation();
8      const [garden, setGarden] = useState(null);
9      const [formData, setFormData] = useState({
10         name: '',
11         location: '',
12         director: '',
13         email: '',
14         phone: ''
15     });
16     const [message, setMessage] = useState('');
17     const navigate = useNavigate();
18 
19     useEffect(() => {
20         fetchUserGarden();
21     }, []);
22 
23     const fetchUserGarden = async () => {
24         try {
25             const token = localStorage.getItem('token');
26             const response = await fetch('https://localhost:7077/api/gardens/user-garden', {
27                 headers: {
28                     'Authorization': `Bearer ${token}`
29                 }
30             });
31             if (!response.ok) {
32                 const errorData = await response.json();
33                 console.error('Error fetching garden:', errorData.message);
34                 setGarden(null);
35                 return;
36             }
37             const data = await response.json();
38             setGarden(data);
39             setFormData({
40                 name: data.name,
41                 location: data.location,
42                 director: data.director,
43                 email: data.email,
44                 phone: data.phone
45             });
46         } catch (error) {
47             console.error('Error fetching garden:', error);
48         }
49     };
50 
51     const handleViewRooms = (gardenId) => {
52         navigate(`/gardens/${gardenId}/rooms`);
53     };
54 
55     const handleChange = (e) => {
56         const { name, value } = e.target;
57         setFormData({ ...formData, [name]: value });
58     };
59 
60     const handleSubmit = async (e) => {
61         e.preventDefault();
62         try {
63             const token = localStorage.getItem('token');
64             const response = await fetch('https://localhost:7077/api/gardens/user-garden', {
65                 method: 'PUT',
66                 headers: {
67                     'Content-Type': 'application/json',
68                     'Authorization': `Bearer ${token}`
69                 },
70                 body: JSON.stringify(formData)
71             });
72             if (!response.ok) {
73                 const errorData = await response.json();
74                 setMessage(errorData.message || t('Error updating garden'));
75                 return;
76             }
77             setMessage(t('Garden updated successfully'));
78             fetchUserGarden();
79         } catch (error) {
80             console.error('Error updating garden:', error);
81             setMessage(t('Error updating garden'));
82         }
83     };
84 
85     return (
86         <div className="gardens-container">
87             <FullScreenImage />
88             <div className="gardens-content">
89                 <h1>{t('WelcomeToGarden')}</h1>
90                 {garden ? (
91                     <div className="vertical-menu">
92                         <div className="menu-item">
93                             <strong>{t('Name')}:</strong> {garden.name}
94                         </div>
95                         <div className="menu-item">
96                             <strong>{t('Location')}:</strong> {garden.location}
97                         </div>
98                         <div className="menu-item">
99                             <strong>{t('Director')}:</strong> {garden.director}
100                        </div>
101                        <div className="menu-item">
102                            <strong>{t('Email')}:</strong> {garden.email}
103                        </div>
104                        <div className="menu-item">
105                            <strong>{t('Phone')}:</strong> {garden.phone}
106                        </div>
107                        <div className="menu-item">
108                            <button onClick={() => handleViewRooms(garden.id)}>{t('Rooms')}</button>
109                        </div>
110                        <form onSubmit={handleSubmit}>
111                            <div className="form-group">
112                                <label>{t('Name')}</label>
113                                <input
114                                    type="text"
115                                    name="name"
116                                    value={formData.name}
117                                    onChange={handleChange}
118                                />
119                            </div>
120                            <div className="form-group">
121                                <label>{t('Location')}</label>
122                                <input
123                                    type="text"
124                                    name="location"
125                                    value={formData.location}
126                                    onChange={handleChange}
127                                />
128                            </div>
129                            <div className="form-group">
130                                <label>{t('Director')}</label>
131                                <input
132                                    type="text"
133                                    name="director"
134                                    value={formData.director}
135                                    onChange={handleChange}
136                                />
137                            </div>
138                            <div className="form-group">
139                                <label>{t('Email')}</label>
140                                <input
141                                    type="email"
142                                    name="email"
143                                    value={formData.email}
144                                    onChange={handleChange}
145                                />
146                            </div>
147                            <div className="form-group">
148                                <label>{t('Phone')}</label>
149                                <input
150                                    type="text"
151                                    name="phone"
152                                    value={formData.phone}
153                                    onChange={handleChange}
154                                />
155                            </div>
156                            <button type="submit" className="save-button">{t('Save')}</button>
157                            {message && <p className="message">{message}</p>}
158                        </form>
159                    </div>
160                ) : (
161                    <p>{t('NoGardenAssigned')}</p>
162                )}
163            </div>
164        </div>
165    );
166 };
167 
168 export default Gardens;

Код Registration.js
1   import React, { useState } from 'react';
2   import { useTranslation } from 'react-i18next';
3   import FullScreenImage from './FullScreenImage'; // Assuming you have this component
4   
5   const Registration = () => {
6       const { t } = useTranslation();
7       const [formData, setFormData] = useState({
8           username: '',
9           firstName: '',
10          lastName: '',
11          email: '',
12          password: '',
13          phone: '',
14          role: '',
15      });
16  
17      const [message, setMessage] = useState('');
18  
19      const handleChange = (e) => {
20          const { name, value } = e.target;
21          setFormData({
22              ...formData,
23              [name]: value,
24          });
25      };
26  
27      const handleSubmit = async (e) => {
28          e.preventDefault();
29          try {
30              const response = await fetch('https://localhost:7077/api/users/register', {
31                  method: 'POST',
32                  headers: {
33                      'Content-Type': 'application/json',
34                  },
35                  body: JSON.stringify(formData),
36              });
37              if (response.ok) {
38                  setMessage(t('SuccessfulRegistration'));
39              } else {
40                  const data = await response.json();
41                  if (data.message === "Username already exists") {
42                      setMessage(t('Username already exists'));
43                  } else if (data.message === "Email already exists") {
44                      setMessage(t('Email already exists'));
45                  } else {
46                      setMessage(t('RegistrationError'));
47                  }
48              }
49          } catch (error) {
50              setMessage(t('RegistrationError'));
51          }
52      };
53  
54      return (
55          <div>
56              <FullScreenImage />
57              <div className="form-container">
58                  <div className="form-title">{t('Registration')}</div>
59                  <form className="form" onSubmit={handleSubmit}>
60                      <input type="text" name="username" placeholder={t('Username')} onChange={handleChange} />
61                      <input type="text" name="firstName" placeholder={t('FirstName')} onChange={handleChange} />
62                      <input type="text" name="lastName" placeholder={t('LastName')} onChange={handleChange} />
63                      <input type="email" name="email" placeholder={t('Email')} onChange={handleChange} />
64                      <input type="password" name="password" placeholder={t('Password')} onChange={handleChange} />
65                      <input type="text" name="phone" placeholder={t('Phone')} onChange={handleChange} />
66                      <select name="role" className="form-select" defaultValue="" onChange={handleChange}>
67                          <option value="" disabled>{t('SelectRole')}</option>
68                          <option value="employee">{t('Employee')}</option>
69                          <option value="parent">{t('Parent')}</option>
70                      </select>
71                      <button type="submit">{t('Register')}</button>
72                  </form>
73                  {message && <div className="form-message">{message}</div>}
74              </div>
75          </div>
76      );
77  };
78  
79  export default Registration;
